---
title: Solanaä¸Anchorçš„å¼€å‘
sidebar_position: 4
---

# Solanaä¸Anchorçš„å¼€å‘

## æ¦‚è¿°

Anchoræ˜¯ä¸€ä¸ªRustæ¡†æ¶ï¼Œç”¨äºåœ¨SolanaåŒºå—é“¾ä¸Šåˆ›å»ºdAppsã€‚åœ¨Solanaä¸Šå¼€å‘çš„ä¸€ä¸ªç‰¹ç‚¹æ˜¯éœ€è¦ä½¿ç”¨å¤§é‡çš„æ¨¡æ¿ä»£ç ï¼Œè¿™å¯èƒ½æ˜¯ä¸€ä¸ªè€—æ—¶ä¸”æ˜‚è´µçš„è¿‡ç¨‹ã€‚Anchoré€šè¿‡æä¾›å„ç§å·¥å…·ï¼ˆå¦‚è´¦æˆ·å’ŒæŒ‡ä»¤æ•°æ®çš„(å)åºåˆ—åŒ–ï¼‰æ¥ç®€åŒ–è¿™ä¸ªè¿‡ç¨‹ï¼Œå‡å°‘å¼€å‘æ—¶é—´ã€‚

## ä¼˜ç‚¹å’Œç¼ºç‚¹

å°±åƒä¸–ç•Œä¸Šçš„ä¸€åˆ‡ä¸€æ ·ï¼ŒAnchoræœ‰å¥½çš„å’Œåçš„ä½¿ç”¨æƒ…å†µã€‚ä»¥ä¸‹æ˜¯ä¸€ä¸ªç®€è¦çš„æ£€æŸ¥æ¸…å•ï¼Œå‘Šè¯‰ä½ ä½•æ—¶åº”è¯¥é€‰æ‹©Anchorè€Œä¸æ˜¯çº¯solana-sdkğŸ‘‰ï¼š

- è¿™ä¸ªé¡¹ç›®å°†ä¸ä»…ä»…æ˜¯ä¸€ä¸ªåˆåŒå’Œä¸€ä¸ªé¡µé¢çš„ç”³è¯·ã€‚
- è¯¥é¡¹ç›®å°†æ‹¥æœ‰å¤æ‚çš„è´¦æˆ·ç®¡ç†ã€‚
- è¯¥é¡¹ç›®åœ¨é“¾ä¸Šå­˜å‚¨äº†è®¸å¤šä¸åŒçš„æ¨¡å‹ï¼Œå¹¶ä¸”æ‹¥æœ‰å¤æ‚çš„WebUIä¸å…¶è¿›è¡Œäº¤äº’ã€‚
- è¯¥é¡¹ç›®å°†ä¸ä½¿ç”¨Anchorç¼–å†™çš„ç¨‹åºè¿›è¡Œäº¤äº’ã€‚

å¦ä¸€æ–¹é¢ï¼Œåœ¨ä»¥ä¸‹æƒ…å†µä¸‹ï¼Œæ‚¨å¯èƒ½æ›´å–œæ¬¢çº¯Solana-SDKè€Œä¸æ˜¯Anchoræ¡†æ¶ğŸ‘‡ã€‚

- ç®€å•çš„å°å‹é¡¹ç›®ï¼Œå…·æœ‰ç®€å•çš„Webç”¨æˆ·ç•Œé¢ã€‚
- è¯¥é¡¹ç›®éœ€è¦å¯¹ä¼ é€’çš„æ•°æ®è¿›è¡Œç²¾ç¡®æ§åˆ¶ï¼ŒåŒ…æ‹¬å­˜å‚¨æ–¹å¼å’Œè°ƒç”¨çš„BPFæŒ‡ä»¤ã€‚
- é¡¹ç›®çš„å®‰å…¨é—®é¢˜éå¸¸é‡è¦ã€‚
- ä¸æ‚¨çš„é¡¹ç›®çš„äº¤äº’ä»…é™äºåŸºäºRustçš„è½¯ä»¶ï¼Œå› æ­¤æ‚¨ä¸éœ€è¦æ¥å£æè¿°è¯­è¨€ï¼ˆä»¥ä¸‹ç®€ç§°IDLï¼‰ã€‚

æ ¹æ®æ‚¨çš„æƒ…å†µé€‰æ‹©é€‚å½“çš„å·¥å…·é›†ã€‚

## å®‰è£…

æˆ‘ä»¬ä¸æä¾›å®‰è£…è¯´æ˜ï¼Œå› ä¸ºå®ƒä»¬å¯èƒ½ä¼šå‘ç”Ÿå˜åŒ–ã€‚åœ¨ç»§ç»­ä¸‹ä¸€æ­¥ä¹‹å‰ï¼Œè¯·å‚è€ƒå®˜æ–¹æ–‡æ¡£https://www.anchor-lang.com/docs/installation ä¸­çš„è¯´æ˜ã€‚

:::caution
ğŸš¨è­¦å‘Šï¼Œåœ¨ç¼–å†™æœ¬è¯¾ç¨‹æ—¶ï¼Œv1.15.xç‰ˆæœ¬å­˜åœ¨ä¸€äº›é—®é¢˜ã€‚æˆ‘ä»¬å¸Œæœ›è¿™äº›é—®é¢˜èƒ½å¤Ÿå°½å¿«è§£å†³ã€‚ç„¶è€Œï¼Œå¦‚æœé—®é¢˜ä»ç„¶å­˜åœ¨ï¼Œæˆ‘ä»¬å»ºè®®ä½¿ç”¨å½“å‰çš„v.1.14.xç‰ˆæœ¬ã€‚
:::

## ä¸»è¦ç¼–ç¨‹æ”¯æŸ±

åœ¨æœ¬æ•™ç¨‹ä¸­ï¼Œæˆ‘ä»¬å°†ä»‹ç»å››ä¸ªå…³é”®çš„å®ï¼Œå®ƒä»¬æå¤§åœ°ç®€åŒ–äº†å¼€å‘è¿‡ç¨‹ï¼Œå¹¶ä½¿Anchorå˜å¾—å¦‚æ­¤å¸å¼•äººã€‚

è®©æˆ‘ä»¬ä»¥Anchoræ¡†æ¶å¼€å‘è€…çš„ä¸€ä¸ªæµ‹è¯•æ¡ˆä¾‹æ¥è€ƒè™‘å®ƒä»¬ï¼Œå³ä¸€ä¸ªç®€å•çš„å»ä¸­å¿ƒåŒ–åº”ç”¨ç¨‹åºï¼Œå®ƒå¯ä»¥è¿›è¡Œè·¨ç¨‹åºè°ƒç”¨ï¼ˆCPIï¼‰ã€‚ä¸ºäº†åšåˆ°è¿™ä¸€ç‚¹ï¼Œæˆ‘ä»¬å»ºè®®æŒ‰ç…§æœ¬è¯¾ç¨‹ä¸­çš„ä¸‹ä¸€æ­¥è¿›è¡Œæ“ä½œã€‚æ‚¨è¿˜å¯ä»¥åœ¨Anchorå­˜å‚¨åº“çš„`tests/cpi-returns`æ–‡ä»¶å¤¹ä¸­æ‰¾åˆ°æ­¤é¡¹ç›®ã€‚

è®©æˆ‘ä»¬ä»åˆå§‹åŒ–é¡¹ç›®å¼€å§‹ğŸ‘‡ï¼š

```bash
anchor init cpi-returns
```

æ¥ä¸‹æ¥ï¼Œè½¬åˆ°é¡¹ç›®å¹¶æ„å»ºå®ƒï¼Œä»¥æ£€æŸ¥æ‚¨çš„ç¯å¢ƒæ˜¯å¦è®¾ç½®æ­£ç¡®

```bash
cd cpi-returns
anchor build
```

å¦‚æœç¯å¢ƒè®¾ç½®æ­£ç¡®ï¼Œæ‚¨åº”è¯¥å¾—åˆ°ä»¥ä¸‹è¾“å‡ºğŸ‘‡ï¼š

![](./img/anchor-build-successful.png)

:::caution
â—ï¸æ³¨æ„ï¼šå¦‚æœä½ é‡åˆ°ç±»ä¼¼çš„é”™è¯¯ï¼š

![](./img/anchor-build-error.png)

åœ¨Cargo.lockæ–‡ä»¶ä¸­ï¼Œæ‰¾åˆ°"solana-program"åŒ…ï¼Œå¹¶å°†å…¶æ›´æ”¹ä¸ºå…ˆå‰æ¨èçš„ç‰ˆæœ¬ï¼Œå¹¶å®Œå…¨åˆ é™¤"checksum"å­—æ®µã€‚é‡å¤è¯¥å‘½ä»¤ã€‚

```bash
anchor build
```
:::

ä¸ºç¡®ä¿ç¯å¢ƒæ­£ç¡®ï¼Œè¯·æ‰§è¡Œä»¥ä¸‹å‘½ä»¤ğŸ‘‰ï¼š

```bash
anchor test
```

è¾“å‡ºæ˜¯ä¸€ä¸ªæˆåŠŸçš„æµ‹è¯•ï¼Œè¿™æ˜¯Anchoræ¡†æ¶å‹å¥½åœ°ä¸ºæˆ‘ä»¬æä¾›çš„ï¼ˆå°½ç®¡å®ƒå®é™…ä¸Šè°ƒç”¨äº†initializeæ–¹æ³•å¹¶æ²¡æœ‰æµ‹è¯•ä»»ä½•ä¸œè¥¿ï¼‰ã€‚

é¦–å…ˆï¼Œæˆ‘ä»¬å°†æ£€æŸ¥ç”±Anchoråˆå§‹åŒ–åœ¨ğŸ‘‰å¤„ç”Ÿæˆçš„ä»£ç 

```rust
use anchor_lang::prelude::*;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod cpi_returns {
    use super::*;

    pub fn initialize(ctx: Context) -> Result<()> {
        ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize {}
```

ç¬¬ä¸€è¡ŒåŒ…å«äº†`anchor_lang::prelude`ï¼Œè¿™æ˜¯crateä¸­å¸¸ç”¨çš„æ‰€æœ‰ç»„ä»¶ã€‚æ ¹æ®å®˜æ–¹æ–‡æ¡£ï¼Œæ‰€æœ‰ç¨‹åºéƒ½åº”è¯¥é€šè¿‡ `anchor_lang::prelude::*`; æ¥åŒ…å«å®ƒã€‚

è¿™é‡Œæˆ‘ä»¬é¦–å…ˆçœ‹åˆ°çš„æ˜¯ `declare_id!` å® ğŸ‘‰:

```rust
declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");
```

è¿™ä¸`solana-sdk`ä¸­çš„`declare_id!`ç±»ä¼¼ã€‚è¿™ä¸ªå®å®šä¹‰äº†æˆ‘ä»¬çš„ç¨‹åºåœ°å€ï¼Œä¸€æ—¦éƒ¨ç½²åˆ°æœ¬åœ°ç½‘ç»œã€å¼€å‘ç½‘ç»œæˆ–ä¸»ç½‘ç»œä¸Šï¼Œå°±ä¼šè¢«ç¡®å®šä¸‹æ¥ã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œå®ƒå¡«å……äº†ä¸€ä¸ªè™šæ‹Ÿå€¼ï¼Œä½ åº”è¯¥åœ¨å‡†å¤‡å¥½éƒ¨ç½²æ—¶å°†å…¶æ›¿æ¢ä¸ºçœŸå®å€¼ã€‚ä¸solana-sdkå¼€å‘ç±»ä¼¼ï¼Œè¿™ä¸ªIDå­˜å‚¨åœ¨`target/deploy/program.json`ä¸­ã€‚ç„¶è€Œï¼Œä¸Solanaä¸åŒçš„æ˜¯ï¼Œè¿™ä¸ªåœ°å€å¿…é¡»åœ¨ä½ çš„ç¨‹åºä¸­ç¡¬ç¼–ç ï¼Œå› ä¸ºå®ƒåœ¨æ‰€æœ‰è€…éªŒè¯ä¸­è¢«ä½¿ç”¨ï¼Œä¾‹å¦‚è®¿é—®ç¨‹åºå­˜å‚¨è´¦æˆ·æ—¶ã€‚

ä¸‹ä¸€ä¸ªç‰‡æ®µæ˜¯ğŸ‘‰:

```rust
#[program]
pub mod cpi_returns {
  use super::*;

  pub fn initialize(ctx: Context) -> Result<()> {
      ok(())
  }
}
```

è¿™æ˜¯æˆ‘ä»¬çš„ä¸»è¦å…¥å£ç‚¹ï¼›æˆ‘ä»¬å¸Œæœ›åœ¨ç¨‹åºä¸­å®ç°çš„æ‰€æœ‰é€»è¾‘éƒ½å°†åœ¨è¿™é‡Œã€‚è¿™å°±æ˜¯Anchorå¦‚ä½•å®ç°`entrypoint.rs`ã€`instruction.rs`å’Œ`processor.rs`çš„æ–¹å¼ã€‚ğŸ‘‰:

```rust
pub fn initialize(ctx: Context) -> Result<()> {
   ok(())
}
```


æ­£å¦‚æˆ‘ä»¬è®°å¾—çš„é‚£æ ·ï¼ŒSolanaéœ€è¦ä¸€ä¸ªå°†è¢«æŸäº›æŒ‡ä»¤ä½¿ç”¨çš„è´¦æˆ·åˆ—è¡¨ã€‚Anchorä¹Ÿæ˜¯å¦‚æ­¤ï¼Œè¿™å°±æ˜¯ä¸ºä»€ä¹ˆæ¯ä¸ªåœ¨`#[program] macro should have a required parameter of type Context , thatâ€™s analog of accounts: &[AccountInfo] `ä¸‹å£°æ˜çš„å‡½æ•°éƒ½éœ€è¦è¿™ä¸ªåˆ—è¡¨ã€‚åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°ä½¿ç”¨Anchorçš„ç¬¬ä¸€ä¸ªå¥½å¤„ï¼Œæˆ‘ä»¬å¯ä»¥å£°æ˜å°½éœ€è¦çš„å…¥å£ç‚¹ï¼Œå¹¶ä¸”æ‰€æœ‰è¿™äº›å…¥å£ç‚¹éƒ½å¯ä»¥é€šè¿‡ä¸ºæˆ‘ä»¬çš„ç¨‹åºç”Ÿæˆçš„IDLè¿›è¡Œè®¿é—®ã€‚

ç”±äºSolanaæ¶æ„çš„åŸå› ï¼Œå†…éƒ¨ä»ç„¶æ˜¯ä¸€ä¸ªå•ä¸€å…¥å£ç‚¹ï¼Œç°åœ¨åªéœ€è¦çŸ¥é“æˆ‘ä»¬å¯ä»¥åœ¨`#[program]`å®ä¸‹å£°æ˜ä»»æ„æ•°é‡çš„å‡½æ•°ï¼Œæ‰€æœ‰è¿™äº›å‡½æ•°éƒ½å¯ä»¥è¢«å®¢æˆ·ç«¯ä»£ç è®¿é—®ã€‚

æ­¤å¤–ï¼ŒAnchorè´Ÿè´£æŒ‡ä»¤æ•°æ®çš„åºåˆ—åŒ–ï¼Œå› æ­¤æ‚¨å¯èƒ½éœ€è¦é¢å¤–çš„å‚æ•°æ¥æ‰§è¡Œæ‰€éœ€ç±»å‹çš„å‡½æ•°ã€‚ä½†è¯·è®°ä½ï¼Œå¦‚æœæ‚¨æƒ³ä½¿ç”¨æµ®ç‚¹æ•°ï¼Œåœ¨ç”¨æˆ·ç•Œé¢ä¸Šæ— æ³•å¾ˆå¥½åœ°å¤„ç†è¯¥ç±»å‹ï¼Œå› ä¸ºæ²¡æœ‰ä¸ºè¯¥ç±»å‹è¿›è¡Œåºåˆ—åŒ–ã€‚æ— è®ºå¦‚ä½•ï¼Œåœ¨åŒºå—é“¾ä¸­ä½¿ç”¨æµ®ç‚¹æ•°è¢«è®¤ä¸ºæ˜¯ä¸è‰¯å®è·µï¼Œæ‰€ä»¥æ‚¨åº”è¯¥é¿å…ä½¿ç”¨å®ƒä»¬ã€‚

```rust
#[derive(Accounts)]
pub struct Initialize {}
```

:::info
æ•°æ®å¸ƒå±€
ä¸ Solana ä¸­çš„è®¸å¤šå…¶ä»–é“¾ä¸åŒï¼Œæ•°æ®ä»¥åŸå§‹å­—èŠ‚å½¢å¼å­˜å‚¨ã€‚ä¸ºäº†ä¿æŒæ•°æ®çš„ä¸€è‡´æ€§ï¼Œæ‰€æœ‰ä¿¡æ¯éƒ½é€šè¿‡ borsh åº“è¿›è¡Œåºåˆ—åŒ–å’Œååºåˆ—åŒ–ï¼Œå¹¶å…·æœ‰ç›¸åº”çš„å¸ƒå±€ï¼š


|Types|	Space in bytes	 | Details/Example |
| ---- | --------------- | --------------- |
| bool | 1	 | would only require 1 bit but still uses 1 byte |
| u8/i8 | 1	 | |
|u16/i16|	2| |
|u32/i32|	4| |
|u64/i64|	8| |
|u128/i128	|16| |
|[T;amount]	|space(T) * amount|	e.g. space([u16;32]) = 2 * 32 = 64|
|Pubkey|	32| |
|Vec T>	| 4 + (space(T) * amount)|	Account size is fixed so |account should be initialized with sufficient space from the beginning|
|String	|4 + length of string in bytes	|Account size is fixed so account should be initialized with sufficient space from the beginning|
|Option T>	|1 + (space(T))	|
|Enum	|1 + Largest Variant Size|	e.g. Enum { A, B { val: u8 }, C { val: u16 } } -> 1 + space(u16) = 3|
|f32	|4	serialization will fail for NaN|
|f64	|8 |	serialization will fail for NaN|

é™¤äº†è´¦æˆ·æ•°æ®çš„ç©ºé—´å¤–ï¼Œæ‚¨è¿˜éœ€è¦ä¸ºAnchorçš„å†…éƒ¨é‰´åˆ«å™¨å¢åŠ 8ä¸ªå­—èŠ‚çš„ç©ºé—´é™åˆ¶

ğŸ‘€ å‘ç°æ›´å¤šï¼š[Anchor æ–‡æ¡£ / AnchorSerialize, Anchor / Space](https://docs.rs/anchor-lang/latest/anchor_lang/trait.AnchorSerialize.html)

:::

è¿™ä¸ªæŒ‡ä»¤å®šä¹‰äº†åˆå§‹åŒ–å…¥å£ç‚¹çš„ä¸Šä¸‹æ–‡ï¼Œå¹¶ä¸”åœ¨ä½ å¯¹æŸä¸ªè´¦æˆ·æ•°æ®è¿›è¡Œäº¤äº’æ—¶ä½¿ç”¨ï¼›åœ¨ç®€å•æƒ…å†µä¸‹ï¼Œå®ƒæ˜¯ç©ºçš„ï¼Œå› ä¸ºæˆ‘ä»¬ç›®å‰ä¸éœ€è¦ä»»ä½•è´¦æˆ·æ•°æ®è¿›è¡Œåˆå§‹åŒ–ã€‚ä½ å¯ä»¥å°†å…¶è§†ä¸ºä¸€ç§Anchoræ–¹æ³•ï¼Œç”¨äºç®¡ç† `state.rs` æ–‡ä»¶ä¸­çš„è´¦æˆ·çŠ¶æ€ã€‚

æ­£å¦‚ä½ æ‰€çœ‹åˆ°çš„ï¼ŒAnchorå’Œsolana-sdkåšçš„äº‹æƒ…æ˜¯ä¸€æ ·çš„ï¼Œåªä¸è¿‡æ›´åŠ ç›´æ¥ã€‚ç„¶è€Œï¼Œåœ¨è¿™ç§ç®€å•æ€§ä¹‹ä¸‹éšè—ç€è®¸å¤šæ°´ä¸‹çš„å²©çŸ³å’Œä»£ç åŸºç¡€ã€‚

Anchorçš„ç¨‹åºä¾èµ–äºä»¥ä¸‹åŸºæœ¬å®ğŸ‘‡ï¼š

- `declare_id!` å® - åˆ›å»ºä¸€ä¸ªå­˜å‚¨ç¨‹åºåœ°å€çš„IDå­—æ®µã€‚Anchorä½¿ç”¨è¿™ä¸ªç¡¬ç¼–ç çš„IDè¿›è¡Œå®‰å…¨æ£€æŸ¥ï¼Œå¹¶å…è®¸å…¶ä»–åŒ…è®¿é—®ä½ çš„ç¨‹åºåœ°å€ï¼›
- `#[program]` å® - æ ‡è®°æ‚¨å®šä¹‰ä¸šåŠ¡é€»è¾‘çš„æ¨¡å—ã€‚ä¸ºæ­¤ï¼Œæ‚¨ç¼–å†™å¯ä»¥ç”±å®¢æˆ·ç«¯æˆ–å…¶ä»–ç¨‹åºè°ƒç”¨çš„å‡½æ•°ï¼›
- `#[derive(Accounts)]` å® - å®ƒæ ‡è®°äº†è´¦æˆ·ç»“æ„ï¼Œæ‚¨å¯ä»¥åœ¨å…¶ä¸­å®šä¹‰æ‚¨çš„æŒ‡ä»¤æœŸæœ›çš„è´¦æˆ·ä»¥åŠè¿™äº›è´¦æˆ·åº”éµå®ˆçš„é™åˆ¶ã€‚æ‚¨å¯ä»¥ä½¿ç”¨ä¸¤ä¸ªæ„é€ æ¥å®ç°è¿™ä¸€ç‚¹ï¼šç±»å‹å’Œçº¦æŸã€‚

ä¸ºäº†ç†è§£Anchoråœ¨Solanaä¸Šç®€åŒ–å¼€å‘çš„ç¨‹åº¦ï¼Œè®©æˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹ç›¸åŒçš„ç¨‹åºï¼Œä½†æ˜¯ä»£ç å·²ç»é€šè¿‡å®æ˜ç¡®å°è£…èµ·æ¥ã€‚ä¸ºæ­¤ï¼Œè®©æˆ‘ä»¬ä½¿ç”¨å®ç”¨å·¥å…·`cargo expand`ã€‚

[expland.rs](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=aa461bab7569ba937912b6311252b2f4)

æ­£å¦‚ä½ æ‰€çœ‹åˆ°çš„ï¼Œæˆ‘ä»¬è¿™ä¸ªå°ç¨‹åºï¼ŒåŸæœ¬åªæœ‰å‡ åè¡Œä»£ç ï¼Œç°åœ¨å·²ç»å‘å±•åˆ°äº†å‡ åƒè¡Œä»£ç ã€‚è¿™å°±æ˜¯å®çš„å¨åŠ›ï¼æœ€é‡è¦çš„æ˜¯ä¸è¦å®³æ€•â€”â€”ç°åœ¨æˆ‘ä»¬ä¼šç¨å¾®è§£æä¸€ä¸‹å®ƒä»¬ã€‚åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°å¾ˆå¤šä¸åŒçš„ä»£ç ï¼ˆå…¶ä¸­å¤§éƒ¨åˆ†æ˜¯ç”±Anchorå‹å¥½åœ°ä¸ºæˆ‘ä»¬ç”Ÿæˆçš„IDLä»£ç ï¼‰ã€‚

ç¬¬8è¡Œä»`â€œdeclare_idï¼â€`å®çš„ç¡¬ç¼–ç åœ°å€ç”Ÿæˆæˆ‘ä»¬çš„IDå˜é‡ã€‚

æˆ‘ä»¬è¿˜å¯ä»¥çœ‹åˆ°è¯„è®ºï¼Œå®ƒä»¬å¾ˆå¥½åœ°å‘Šè¯‰æˆ‘ä»¬è¿™é‡Œçš„äº‹æƒ…æ˜¯å¦‚ä½•çœŸå®è¿ä½œçš„ã€‚

Anchor codegenå…¬å¼€äº†ä¸€ç§ç¼–ç¨‹æ¨¡å‹ï¼Œç”¨æˆ·å¯ä»¥åœ¨ä¸€ä¸ªæ¨¡å—å†…å®šä¹‰ä¸€ç»„æ–¹æ³•ï¼Œç±»ä¼¼äºç¼–å†™RPCè¯·æ±‚å¤„ç†ç¨‹åºã€‚ç„¶åï¼Œå®ä¼šç”Ÿæˆä¸€äº›ä»£ç ï¼Œå°†è¿™äº›ç”¨æˆ·å®šä¹‰çš„æ–¹æ³•åŒ…è£…æˆå¯ä»¥åœ¨Solanaä¸Šæ‰§è¡Œçš„å†…å®¹ã€‚

è¿™äº›æ–¹æ³•æš‚æ—¶å½’ä¸ºä¸€ç±»ã€‚

å…¨å±€æ–¹æ³• - åœ¨ `#[program]` å†…éƒ¨çš„å¸¸è§„æ–¹æ³•ã€‚

ä»£ç ç”Ÿæˆå™¨å¿…é¡»å°å¿ƒå¤„ç†è¿™äº›ä¸åŒå‘½åç©ºé—´ä¸­æ–¹æ³•ä¹‹é—´çš„å†²çªã€‚å› æ­¤ï¼ŒAnchorä½¿ç”¨ä¸€ç§å˜ä½“çš„sighashæ¥æ‰§è¡Œæ–¹æ³•è°ƒåº¦ï¼Œè€Œä¸æ˜¯åƒç®€å•çš„æšä¸¾å˜ä½“é‰´åˆ«å™¨é‚£æ ·ã€‚

ç”Ÿæˆä»£ç çš„æ‰§è¡Œæµç¨‹å¯ä»¥å¤§è‡´æ¦‚è¿°å¦‚ä¸‹ğŸ‘‡ï¼š


- é€šè¿‡å…¥å£ç‚¹ï¼ˆç¬¬53è¡Œï¼‰å¯åŠ¨ç¨‹åºã€‚
- å°†æŒ‡ä»¤æ•°æ®çš„å‰8ä¸ªå­—èŠ‚ä¸­çš„æ–¹æ³•æ ‡è¯†ç¬¦å‰¥ç¦»ï¼Œå¹¶è°ƒç”¨å·²è¯†åˆ«çš„æ–¹æ³•ï¼ˆç¬¬161è¡Œï¼‰ã€‚æ–¹æ³•æ ‡è¯†ç¬¦æ˜¯ sighash çš„ä¸€ç§å˜ä½“ã€‚
- å¦‚æœæ–¹æ³•æ ‡è¯†ç¬¦æ˜¯IDLæ ‡è¯†ç¬¦ï¼Œåˆ™æ‰§è¡ŒIDLæŒ‡ä»¤ï¼Œè¿™æ˜¯æ¯ä¸ªAnchorç¨‹åºä¸­å†…ç½®çš„ä¸€ç»„ç‰¹æ®Šç¡¬ç¼–ç æŒ‡ä»¤ã€‚ç„¶åé€€å‡ºã€‚å¦åˆ™ï¼Œæ–¹æ³•æ ‡è¯†ç¬¦æ˜¯ç”¨æˆ·å®šä¹‰æŒ‡ä»¤çš„æ ‡è¯†ç¬¦ï¼Œå³ç”¨æˆ·å®šä¹‰æ¨¡å—ä¸­çš„æ–¹æ³•ä¹‹ä¸€ã€‚æ‰§è¡Œæ–¹æ³•åˆ†æ´¾ï¼Œå³æ‰§è¡Œå¤§å‹åŒ¹é…è¯­å¥å°†æ–¹æ³•æ ‡è¯†ç¬¦æ˜ å°„åˆ°æ–¹æ³•å¤„ç†ç¨‹åºåŒ…è£…å™¨ï¼ˆç¬¬168è¡Œï¼‰ã€‚
- è¿è¡Œæ–¹æ³•å¤„ç†ç¨‹åºåŒ…è£…å™¨ã€‚è¿™ä¸ªåŒ…è£…å™¨åŒ…è£…äº†ç”¨æˆ·å®é™…ç¼–å†™çš„ä»£ç ï¼Œå¯¹è´¦æˆ·è¿›è¡Œååºåˆ—åŒ–ï¼Œæ„å»ºä¸Šä¸‹æ–‡ï¼Œè°ƒç”¨ç”¨æˆ·çš„ä»£ç ï¼Œæœ€åè¿è¡Œé€€å‡ºä¾‹ç¨‹ï¼Œé€šå¸¸ä¼šæŒä¹…åŒ–è´¦æˆ·æ›´æ”¹ï¼ˆç¬¬170è¡Œå’Œ2343è¡Œï¼‰ã€‚

ğŸ¤“ æ€»çš„æ¥è¯´ï¼Œ`#[program]` æ˜¯ä½¿ç”¨ Anchor æ¡†æ¶åˆ›å»º Solana ç¨‹åºçš„é‡è¦å®ã€‚å®ƒæä¾›äº†ä¸€ç§ç»“æ„åŒ–çš„æ–¹å¼æ¥å®šä¹‰ç¨‹åºçš„è¡Œä¸ºï¼Œå¹¶ä¸ç½‘ç»œä¸Šçš„å…¶ä»–ç¨‹åºè¿›è¡Œäº¤äº’ã€‚

åœ¨Anchorä¸­ï¼Œè¿˜åº”æ˜ç¡®æåŠå¦ä¸€ä¸ªå…³é”®çš„å®ã€‚`#[derive(Accounts)]`å®ä¸ºæ‚¨çš„`T`ç±»å‹ç»“æ„å®ç°äº†ç›¸åº”çš„`T::try_accounts`æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç”¨äº(å)åºåˆ—åŒ–è¾“å…¥è´¦æˆ·å¹¶æ·»åŠ éªŒè¯æ£€æŸ¥ã€‚

ç»“æ„å­—æ®µçš„ï¼ˆåï¼‰åºåˆ—åŒ–éµå¾ª`#[account(...)]`å®çš„é€»è¾‘ï¼Œè¯¥å®æŒ‡å®šæ‚¨å¯¹æ¯ä¸ªè´¦æˆ·åº”ç”¨çš„å¿…è¦çº¦æŸã€‚ä¸ºäº†ç†è§£ï¼Œä¸¾ä¸ªä¾‹å­`#[account(mut @ MyError::MyErrorCode)]` - å®ƒæ£€æŸ¥è´¦æˆ·æ˜¯å¦å¯å˜ã€‚å¦åˆ™ï¼Œæ‚¨å°†ä¼šå¾—åˆ°ä¸€ä¸ªç±»ä¼¼äº`MyError::MyErrorCode`çš„é”™è¯¯ã€‚å¦‚æœä½¿ç”¨äº†`target_account`ï¼Œåˆ™ç›®æ ‡è´¦æˆ·å¿…é¡»å­˜åœ¨äºç»“æ„ä½“ä¸­ï¼Œå¹¶ä¸”`.key()`æ˜¯éšå¼çš„ï¼Œä¾‹å¦‚`payer = authority`ã€‚æ ¹æ®ç»™å®šçš„çº¦æŸï¼Œä»£ç ä¸­ä¼šç”Ÿæˆç›¸åº”çš„æ£€æŸ¥ï¼Œè¿åè¿™äº›æ£€æŸ¥å°†å¯¼è‡´é”™è¯¯å’Œç¨‹åºç»ˆæ­¢ã€‚

æœ‰è®¸å¤šä¸åŒçš„é™åˆ¶ã€‚æ‚¨å¯ä»¥åœ¨ä¸‹é¢çš„æœ‰ç”¨é“¾æ¥ä¸­äº†è§£æ›´å¤šç›¸å…³ä¿¡æ¯ã€‚

ä½œä¸ºæ•™ç¨‹çš„ä¸€éƒ¨åˆ†ï¼Œæˆ‘ä»¬å°†ä¿®æ”¹æˆ‘ä»¬çš„é¡¹ç›®ï¼Œä»¥æ›´æ·±å…¥åœ°äº†è§£SolanaåŒºå—é“¾ç¨‹åºçš„å·¥ä½œåŸç†ã€‚å½“ç„¶ï¼Œæ‚¨å¯ä»¥æ ¹æ®ä¸‹é¢çš„ç¤ºä¾‹è‡ªç”±ç¼–å†™ä»»ä½•é€»è¾‘ï¼Œå› ä¸ºæœ€ç»ˆåœ¨å¼€å‘ä¸­ï¼Œä¸€åˆ‡éƒ½åªæ˜¯è¯»å–ã€å¤„ç†å’Œå†™å…¥ä¸€äº›å­—èŠ‚ï¼Œæˆ‘ä»¬å°†å‘æ‚¨å±•ç¤ºå¦‚ä½•åœ¨Anchorä¸­å®ç°è¿™ä¸€ç‚¹ã€‚

## å¤šç¨‹åºdApp

ğŸ¤“ åœ¨æœ¬ç« ä¸­ï¼Œæˆ‘ä»¬å°†ç ”ç©¶Anchorçš„å¼€å‘äººå‘˜å‹æƒ…æä¾›çš„ç¤ºä¾‹ç¨‹åºï¼Œä»¥æ•™æˆ‘ä»¬å¦‚ä½•ä½¿ç”¨è¯¥æ¡†æ¶ã€‚æˆ‘ä»¬çš„é¡¹ç›®å°†åŒ…æ‹¬ä¸¤ä¸ªç¨‹åºï¼Œå…¶ä¸­ä¸€ä¸ªå°†æ˜¯è°ƒç”¨ç¨‹åºï¼Œå¦ä¸€ä¸ªå°†æ˜¯è¢«è°ƒç”¨ç¨‹åºï¼Œå®ƒå°†ä¼ é€’ä¸€äº›ç®€å•çš„å€¼ï¼Œæ— è®ºæ˜¯æ•°å­—ã€å‘é‡è¿˜æ˜¯åŸå§‹æ•°æ®ç»“æ„ã€‚

ä¸ºäº†ä¸ç¤ºä¾‹ç›¸åŒ¹é…ï¼Œæˆ‘ä»¬éœ€è¦ä»é¡¹ç›®çš„ç¨‹åºæ–‡ä»¶å¤¹ä¸­ç§»é™¤ç¨‹åº cpi-returns ï¼Œå¹¶ä½¿ç”¨Anchoræ–°å‘½ä»¤åˆ›å»ºä¸¤ä¸ªæ–°ç¨‹åºï¼Œå³ï¼š

```bash
anchor new caller
anchor new callee
```

è®©æˆ‘ä»¬ä»è¢«è°ƒç”¨ç¨‹åºçš„åˆå§‹åŒ–æ–¹æ³•å¼€å§‹ğŸ‘‡ï¼š

```rust
pub fn initialize(ctx: Context) -> Result<()> {
    ok(())
}
```

ç›®å‰ï¼Œå®ƒæ˜¯ç©ºçš„ã€‚æˆ‘ä»¬éœ€è¦ä¸€ä¸ªä¸æˆ‘ä»¬çš„ç¨‹åºå…³è”çš„å­˜å‚¨è´¦æˆ·ï¼Œåœ¨é‚£é‡Œæˆ‘ä»¬å°†ç§Ÿç”¨ä¸€äº›å­—èŠ‚å¹¶å­˜å‚¨æˆ‘ä»¬çš„çŠ¶æ€ã€‚åœ¨Anchorä¸­ï¼Œå¯ä»¥æŒ‰ç…§ä»¥ä¸‹æ–¹å¼å®ŒæˆğŸ‘‡ï¼š

```rust
#[account]
pub struct CpiReturnAccount {
   pub value: u64,
}
```

`#[account]` å®æ‰§è¡Œäº†å‡ ä¸ªé‡è¦çš„æ“ä½œï¼šå®ƒä¸ºæˆ‘ä»¬çš„ç»“æ„æä¾›äº†å¿…è¦çš„åºåˆ—åŒ–å’Œååºåˆ—åŒ–åŠŸèƒ½ï¼Œä½†æœ€é‡è¦çš„æ˜¯ï¼Œè¿™ä¸ªå±æ€§å°†æ•°æ®çš„æ‰€æœ‰è€…è®¾ç½®ä¸ºæˆ‘ä»¬åœ¨`declare_id!`ä¸­é…ç½®çš„åœ°å€ã€‚

å½“æŒ‡ä»¤å¯¹è´¦æˆ·çš„ååºåˆ—åŒ–æ•°æ®æ„Ÿå…´è¶£æ—¶ï¼Œä½¿ç”¨ Account ç±»å‹ã€‚

ä½†æ˜¯ï¼Œä¸Šé¢çš„ç»“æ„åªæ˜¯æè¿°äº†ä¸€ä¸ªå­˜å‚¨æ¨¡å¼ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦ä»¥æŸç§æ–¹å¼å°†å…¶ä¸å…·ä½“çš„è´¦æˆ·è¿æ¥èµ·æ¥ã€‚ä½¿ç”¨Anchorï¼Œæ‚¨å¯ä»¥æŒ‰ç…§ä»¥ä¸‹æ–¹å¼å®Œæˆï¼š

```rust
#[derive(Accounts)]
pub struct Initialize<'info> {
  #[account(init, payer = user, space = 8 + 8)]
  pub account: Account<'info, CpiReturnAccount>,
  #[account(mut)]
  pub user: Signer<'info>,
  pub system_program: Program<'info, System>,
}
```

è¿™ä¸æˆ‘ä»¬åœ¨solana-sdkä¸­çœ‹åˆ°çš„ä¸åŒï¼Œä½†æ­£å¦‚æ‚¨åœ¨ä¸‹é¢çœ‹åˆ°çš„é‚£æ ·ï¼Œå®ƒæä¾›äº†ç›¸åŒçš„åŠŸèƒ½ã€‚

é¦–å…ˆï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°Initializeç»“æ„ä½“è¢«æ ‡è®°ä¸º`#[derive(Accounts)]`ï¼Œè¿™å°†æ‰§è¡Œç±»ä¼¼äºğŸ‘‡çš„æ“ä½œï¼š

```rust
accounts: &[AccountInfo],
```

åœ¨solana-sdkçš„initializeæ–¹æ³•ä¸­çš„å‚æ•°ã€‚

```rust
#[account(init, payer = user, space = 8 + 8)]
pub account: Account<'info, CpiReturnAccount>,
```

æˆ‘ä»¬éœ€è¦ä¸€ä¸ªè´¦æˆ·æ¥å­˜å‚¨ä¸€äº›æ•°æ®ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦

```rust
pub account: Account<'info, CpiReturnAccount>
```

ç”±äºæ­¤è´¦æˆ·å°šä¸å­˜åœ¨ï¼Œå› æ­¤æ ‡è®°ä¸ºåˆå§‹çº¦æŸã€‚æ­¤å¤–ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªæ”¯ä»˜ç§Ÿé‡‘è±å…çš„ä»˜æ¬¾äººè´¦æˆ·ã€‚ä¸ºæ­¤ï¼Œæˆ‘ä»¬æ·»åŠ äº†ä¸€ä¸ªæˆæƒè´¦æˆ·ã€‚

```rust
#[account(mut)]
pub user: Signer<'info>,
```
å“ªä¸ªäººå°†æˆä¸ºäº¤æ˜“çš„ç­¾ç½²è€…ã€‚æœ€åä¸€ä»¶äº‹æ˜¯

```rust
pub system_program: Program<'info, System>
```

è¿™æ˜¯å¿…éœ€çš„ï¼Œå› ä¸º init éœ€è¦åˆ›å»ºä¸€ä¸ªè´¦æˆ·ï¼Œè€Œæˆ‘ä»¬ä½¿ç”¨ç³»ç»Ÿç¨‹åºæ¥å®Œæˆè¿™ä¸ªä»»åŠ¡ã€‚

è®©æˆ‘ä»¬å°†å…¶ä¸æˆ‘ä»¬çš„åˆå§‹åŒ–æ–¹æ³•ç»“åˆèµ·æ¥ğŸ‘‡ï¼š


```rust
pub fn initialize(ctx: Context) -> Result<()> {
    let account = &mut ctx.accounts.account;
    account.value = 10;
    ok(())
}
```

è®©æˆ‘ä»¬æ·»åŠ ä¸€äº›è¿”å›ç‰¹å®šå€¼çš„æ–¹æ³•ã€‚åœ¨æˆ‘ä»¬çš„æƒ…å†µä¸‹ï¼Œè¿™äº›å€¼å°†æ˜¯ä¸€ä¸ªæ•°å­—ã€ä¸€ä¸ªæ•°ç»„å’Œä¸€ä¸ªç»“æ„ä½“ã€‚æˆ‘ä»¬éœ€è¦ä¸€ä¸ªå•ç‹¬çš„æŒ‡ä»¤æ¥å®Œæˆè¿™ä¸ªä»»åŠ¡ï¼š

```rust
#[derive(Accounts)]
pub struct CpiReturn<'info> {
    pub account: Account<'info, CpiReturnAccount>,
}
```

ä¸ºäº†è¿”å›ä¸€ä¸ªç‹¬ç«‹çš„ç»“æ„ä½“ï¼Œè®©æˆ‘ä»¬åœ¨æ¨¡å—å†…éƒ¨å£°æ˜å®ƒï¼Œå¹¶ä½¿ç”¨å®AnchorSerializeå’ŒAnchorDeserializeæ¥ç¡®ä¿å®ƒè¢«æ­£ç¡®åœ°åºåˆ—åŒ–å’Œååºåˆ—åŒ–ğŸ‘‡ï¼š

```rust
#[derive(AnchorSerialize, AnchorDeserialize)]
pub struct StructReturn {
    pub value: u64,
}
```

ç°åœ¨ï¼Œå°†ä¸Šè¿°æ­¥éª¤ç»“åˆèµ·æ¥ï¼Œå®ç°è¿”å›æ•°å­—10ã€å€¼ä¸º11çš„ç»“æ„ä½“å’ŒåŒ…å«æ•°å­—12ã€13ã€14ã€100çš„æ•°ç»„çš„æ–¹æ³•ï¼Œå¹¶æ·»åŠ ä¸€ä¸ªå…è®¸æ‚¨æŸ¥çœ‹åˆ†é…ç»™è´¦æˆ·çš„å½“å‰æ•°å­—å€¼çš„æ–¹æ³•ğŸ‘‡

```rust
use anchor_lang::prelude::*;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS"
);

#[program]
pub mod callee {
    use super::*;

    #[derive(AnchorSerialize, AnchorDeserialize)]
    pub struct StructReturn {
        pub value: u64,
    }

    pub fn initialize(ctx: Context<Initialize>) -> Result<()> {
        let account = &mut ctx.accounts.account;
        account.value = 10;
        ok(())
    }

    pub fn return_u64(_ctx: Context<CpiReturn>) -> Result<u64> {
        Ok(10)
    }

    pub fn return_struct(_ctx: Context<CpiReturn>) -> Result<StructReturn> {
        let s = StructReturn { value: 11 };
        Ok(s)
    }

    pub fn return_vec(_ctx: Context<CpiReturn>) -> Result<Vec<u8>> {
        Ok(vec![12, 13, 14, 100])
    }

    // Used for testing views
    pub fn return_u64_from_account(ctx: Context<CpiReturn>) -> Result<CpiReturnAccount> {
        let account = &ctx.accounts.account;
        Ok(CpiReturnAccount {
            value: account.value,
        })
    }
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init, payer = user, space = 8 + CpiReturnAccount::INIT_SPACE)]
    pub account: Account<'info, CpiReturnAccount>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct CpiReturn<'info> {
    pub account: Account<'info, CpiReturnAccount>,
}

#[account]
#[derive(InitSpace)]
pub struct CpiReturnAccount {
    pub value: u64,
}
```

è¿™æ ·æˆ‘ä»¬çš„è¢«è°ƒç”¨ç¨‹åºå°±å®Œæˆäº†ã€‚è®©æˆ‘ä»¬ç»§ç»­è¿›è¡Œè°ƒç”¨ç¨‹åºã€‚é¦–å…ˆï¼Œåœ¨è°ƒç”¨è€…é¡¹ç›®çš„ Cargo.toml æ–‡ä»¶ä¸­è¿æ¥æˆ‘ä»¬çš„è¢«è°ƒç”¨ç¨‹åºğŸ‘‡ï¼š

```bash
[dependencies]
anchor-lang = "0.28.0"
callee = { path = "../callee", features = ["cpi"] }
```

ä½¿ç”¨`features = ["cpi"]` çš„ç›®çš„æ˜¯ä¸ºäº†ä¸ä»…å¯ä»¥ä½¿ç”¨è¢«è°ƒç”¨æ–¹çš„ç±»å‹ï¼Œè¿˜å¯ä»¥ä½¿ç”¨å…¶æŒ‡ä»¤æ„å»ºå™¨å’Œ cpi å‡½æ•°ã€‚å¦‚æœæ²¡æœ‰è¿™äº›ï¼Œæˆ‘ä»¬å°†ä¸å¾—ä¸ä½¿ç”¨ä½çº§åˆ«çš„ Solana ç³»ç»Ÿè°ƒç”¨ã€‚å¹¸è¿çš„æ˜¯ï¼ŒAnchor åœ¨è¿™äº›ä¹‹ä¸Šæä¾›äº†æŠ½è±¡ã€‚é€šè¿‡å¯ç”¨ cpi ç‰¹æ€§ï¼Œè°ƒç”¨æ–¹ç¨‹åºå¯ä»¥è®¿é—® `callee::cpi` æ¨¡å—ã€‚Anchor ä¼šè‡ªåŠ¨ç”Ÿæˆæ­¤æ¨¡å—ï¼Œå¹¶ä¸ºç¨‹åºæä¾›é‡èº«å®šåˆ¶çš„æŒ‡ä»¤æ„å»ºå™¨å’Œ cpi åŠ©æ‰‹ã€‚

åœ¨è¢«è°ƒç”¨ç¨‹åºçš„æƒ…å†µä¸‹ï¼Œè°ƒç”¨è€…ä½¿ç”¨è¢«è°ƒç”¨æ–¹çš„`cpi::accounts`æ¨¡å—æä¾›çš„`CpiReturn`æŒ‡ä»¤æ„å»ºå™¨ç»“æ„æ¥æäº¤è¢«è°ƒç”¨ç¨‹åºæœŸæœ›çš„è´¦æˆ·ã€‚ç„¶åï¼Œè°ƒç”¨è€…åˆ›å»ºä¸€ä¸ªæ–°çš„cpiä¸Šä¸‹æ–‡ï¼Œå¹¶å°†å…¶ä¼ é€’ç»™è¢«è°ƒç”¨æ–¹çš„`cpi::some_method`ï¼ˆä¾‹å¦‚return_u64ï¼‰cpiå‡½æ•°ã€‚è¯¥å‡½æ•°ä¸è¢«è°ƒç”¨ç¨‹åºä¸­çš„`return_u64`å‡½æ•°å…·æœ‰å®Œå…¨ç›¸åŒçš„åŠŸèƒ½ï¼Œå”¯ä¸€çš„åŒºåˆ«æ˜¯å®ƒæœŸæœ›ä¸€ä¸ª`CpiContext`è€Œä¸æ˜¯ä¸€ä¸ªContextã€‚

æˆ‘ä»¬å°†éœ€è¦æ¥è‡ªè¢«è°ƒç”¨ç¨‹åºçš„CpiReturnæŒ‡ä»¤ï¼Œè¢«è°ƒç”¨ç¨‹åºæœ¬èº«ä»¥åŠè´¦æˆ·ç»“æ„ã€‚è®©æˆ‘ä»¬å°†å¿…è¦çš„ä¾èµ–é¡¹è¿æ¥åˆ°æˆ‘ä»¬çš„è°ƒç”¨ç¨‹åºä¸­ï¼š

```rust
use anchor_lang::prelude::*;
use callee::cpi::accounts::CpiReturn;
use callee::program::Callee;
use callee::{self, CpiReturnAccount};
```

åˆ›å»ºä¸€æ¡æŒ‡ä»¤ï¼Œæˆ‘ä»¬å°†ä¼ é€’ç»™è°ƒç”¨ç¨‹åºï¼Œä»¥ä»è¢«è°ƒç”¨è€…è°ƒç”¨CPIæ–¹æ³•ğŸ‘‡ï¼š



```rust
#[derive(Accounts)]
pub struct CpiReturnContext<'info> {
    #[account(mut)]
    pub cpi_return: Account<'info, CpiReturnAccount>,
    pub cpi_return_program: Program<'info, Callee>,
}
```
æ˜¯æ—¶å€™å¼€å§‹å®æ–½èƒ½å¤Ÿè¿›è¡ŒCPIè°ƒç”¨çš„æ–¹æ³•äº†ã€‚åœ¨Anchorä¸­ï¼Œå®ƒå°†å¦‚ä¸‹æ‰€ç¤ºğŸ‘‡

```rust
pub fn cpi_call_return_u64(ctx: Context<CpiReturnContext>) -> Result<()> {
    let cpi_program = ctx.accounts.cpi_return_program.to_account_info();
    let cpi_accounts = CpiReturn {
        account: ctx.accounts.cpi_return.to_account_info(),
    };
    let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);
    let result = callee::cpi::return_u64(cpi_ctx)?;
    let solana_return = result.get();
    anchor_lang::solana_program::log::sol_log_data(&[&solana_return.try_to_vec().unwrap()]);
    Ok(())
}
```

ğŸ‘€è®©æˆ‘ä»¬é€è¡Œæ¥çœ‹çœ‹è¿™é‡Œå‘ç”Ÿäº†ä»€ä¹ˆ

è¿™è¡Œä»£ç ä»ä¼ å…¥çš„ä¸Šä¸‹æ–‡ctxä¸­è·å–accountsç»“æ„ä½“çš„cpi_return_programå­—æ®µï¼Œç„¶åä½¿ç”¨å®ƒçš„to_account_infoæ–¹æ³•å°†å…¶è½¬æ¢ä¸ºAccountInfoç»“æ„ä½“ï¼Œè¿™æ˜¯åˆ›å»ºCPIä¸Šä¸‹æ–‡æ‰€éœ€çš„ã€‚

```rust
let cpi_program = ctx.accounts.cpi_return_program.to_account_info();
```

è¿™è¡Œä»£ç å®šä¹‰äº†ä¸€ä¸ªæ–°çš„ç»“æ„ä½“å˜é‡cpi_accountsï¼Œç±»å‹ä¸ºCpiReturnï¼Œå…¶ä¸­åŒ…å«ä¸€ä¸ªå­—æ®µaccountï¼Œè¯¥å­—æ®µè¢«è®¾ç½®ä¸ºæä¾›çš„ctxä¸­æ‰¾åˆ°çš„cpi_returnè´¦æˆ·ã€‚è¿™ä¸ªç»“æ„ä½“å°†ä½œä¸ºCPIä¸Šä¸‹æ–‡çš„ä¸€éƒ¨åˆ†ä½¿ç”¨

```rust
let cpi_accounts = CpiReturn {
    account: ctx.accounts.cpi_return.to_account_info(),
};
```
è¿™è¡Œä»£ç ä½¿ç”¨ä¹‹å‰åˆ›å»ºçš„cpi_programå’Œcpi_accountsåˆ›å»ºäº†ä¸€ä¸ªæ–°çš„CPIä¸Šä¸‹æ–‡ã€‚

```rust
let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);
```

è¿™è¡Œä»£ç è°ƒç”¨äº†è¢«è°ƒç”¨ç¨‹åºä¸­çš„ä¸€ä¸ªåä¸ºreturn_u64çš„å¤–éƒ¨å‡½æ•°ï¼Œå°†åˆ›å»ºçš„CPIä¸Šä¸‹æ–‡cpi_ctxä½œä¸ºè¾“å…¥ä¼ é€’ï¼Œå¹¶å°†ç»“æœå­˜å‚¨åœ¨resultä¸­ã€‚

```rust
let result = callee::cpi::return_u64(cpi_ctx)?;
```

é€šè¿‡åœ¨ç»“æœå¯¹è±¡ä¸Šè°ƒç”¨getæ–¹æ³•ï¼Œæ­¤è¡Œè·å–ç”±return_u64è¿”å›çš„64ä½æ•´æ•°å€¼ã€‚

```rust
let solana_return = result.get();
```

ä½¿ç”¨Anchoræä¾›çš„sol_log_dataï¼Œå°†è¿”å›å€¼ä½œä¸ºå­—èŠ‚æ•°ç»„è®°å½•åˆ°Solanaäº‹åŠ¡æ—¥å¿—ä¸­

```rust
anchor_lang::solana_program::log::sol_log_data(&[&solana_return.try_to_vec().unwrap()]);
```

æœ€åï¼Œè¯¥å‡½æ•°ä¸ºè¿”å›u64çš„ç¨‹åºåˆå§‹åŒ–äº†ä¸€ä¸ªCPIï¼Œç„¶åå°†è¿”å›çš„å€¼å†™å…¥Solanaäº¤æ˜“æ—¥å¿—ã€‚

è®©æˆ‘ä»¬è¿˜æ·»åŠ ä¸€äº›è°ƒç”¨ return_vec å’Œ return_struct æ–¹æ³•çš„æ–¹æ³•ğŸ‘‰:

```rust
pub fn cpi_call_return_struct(ctx: Context<CpiReturnContext>) -> Result<()> {
    let cpi_program = ctx.accounts.cpi_return_program.to_account_info();
    let cpi_accounts = CpiReturn {
        account: ctx.accounts.cpi_return.to_account_info(),
    };
    let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);
    let result = callee::cpi::return_struct(cpi_ctx)?;
    let solana_return = result.get();

    anchor_lang::solana_program::log::sol_log_data(&[&solana_return.try_to_vec().unwrap()]);

    Ok(())
}

pub fn cpi_call_return_vec(ctx: Context<CpiReturnContext>) -> Result<()> {
    let cpi_program = ctx.accounts.cpi_return_program.to_account_info();
    let cpi_accounts = CpiReturn {
        account: ctx.accounts.cpi_return.to_account_info(),
    };
    let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);
    let result = callee::cpi::return_vec(cpi_ctx)?;
    let solana_return = result.get();
    anchor_lang::solana_program::log::sol_log_data(&[&solana_return.try_to_vec().unwrap()]);
    Ok(())
}
```

æœ€åï¼Œè®©æˆ‘ä»¬æ·»åŠ è§†å›¾æ–¹æ³•ã€‚é¦–å…ˆï¼Œè®©æˆ‘ä»¬å£°æ˜ä¸Šä¸‹æ–‡æ‰€éœ€çš„ç»“æ„ğŸ‘‰ï¼š

```rust
#[derive(Accounts)]
pub struct ReturnContext {}
```

åœ¨æ¨¡å—å†…éƒ¨å®ç°ä¸€ä¸ªè¾…åŠ©ç»“æ„ï¼Œè¯¥ç»“æ„ä¹Ÿå°†åœ¨ä½¿ç”¨ReturnContextè¿›è¡Œè°ƒç”¨æ—¶è¿”å›ğŸ‘‰:

```rust

#[derive(AnchorSerialize, AnchorDeserialize)]
pub struct Struct {
    pub a: u64,
    pub b: u64,
}
```

ç°åœ¨è®©æˆ‘ä»¬åœ¨ä»£ç ä¸­å®ç°è¿™äº›æ–¹æ³•æœ¬èº«ï¼Œå®ƒä»¬å°†è¿”å›ä¸€ä¸ªç‰¹å®šçš„æ•°å€¼ï¼Œä¸€ä¸ªåŒ…å«å…ƒç´ 1ã€2ã€3çš„å‘é‡ï¼Œä»¥åŠä¸€ä¸ªåŒ…å«å€¼1å’Œ2çš„ç»“æ„ä½“ğŸ‘‰:

```rust
pub fn return_u64(_ctx: Context<ReturnContext>) -> Result<u64> {
    Ok(99)
}

pub fn return_struct(_ctx: Context<ReturnContext>) -> Result<Struct> {
    Ok(Struct { a: 1, b: 2 })
}

pub fn return_vec(_ctx: Context<ReturnContext>) -> Result<Vec<u8>> {
    Ok(vec![1, 2, 3])
}
```

æ­¤æ—¶æˆ‘ä»¬çš„ç¨‹åºå·²ç»å‡†å¤‡å°±ç»ªã€‚è°ƒç”¨ç¨‹åºçš„å®Œæ•´ä»£ç ğŸ‘‰ï¼š

```rust
use anchor_lang::prelude::*;
use callee::cpi::accounts::CpiReturn;
use callee::program::Caller;
use callee::{self, CpiReturnAccount};

declare_id!("GrvgrRzLjXQdmGY7gAy1LKdmBASFncxyrhSrdtU2tZB9");

#[program]
pub mod caller {
    use super::*;

    #[derive(AnchorSerialize, AnchorDeserialize)]
    pub struct Struct {
        pub a: u64,
        pub b: u64,
    }

    pub fn cpi_call_return_u64(ctx: Context<CpiReturnContext>) -> Result<()> {
        let cpi_program = ctx.accounts.cpi_return_program.to_account_info();
        let cpi_accounts = CpiReturn {
            account: ctx.accounts.cpi_return.to_account_info(),
        };
        let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);
        let result = callee::cpi::return_u64(cpi_ctx)?;
        let solana_return = result.get();
        anchor_lang::solana_program::log::sol_log_data(&[&solana_return.try_to_vec().unwrap()]);
        Ok(())
    }

    pub fn cpi_call_return_struct(ctx: Context<CpiReturnContext>) -> Result<()> {
        let cpi_program = ctx.accounts.cpi_return_program.to_account_info();
        let cpi_accounts = CpiReturn {
            account: ctx.accounts.cpi_return.to_account_info(),
        };
        let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);
        let result = callee::cpi::return_struct(cpi_ctx)?;
        let solana_return = result.get();

        anchor_lang::solana_program::log::sol_log_data(&[&solana_return.try_to_vec().unwrap()]);

        Ok(())
    }

    pub fn cpi_call_return_vec(ctx: Context<CpiReturnContext>) -> Result<()> {
        let cpi_program = ctx.accounts.cpi_return_program.to_account_info();
        let cpi_accounts = CpiReturn {
            account: ctx.accounts.cpi_return.to_account_info(),
        };
        let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);
        let result = callee::cpi::return_vec(cpi_ctx)?;
        let solana_return = result.get();
        anchor_lang::solana_program::log::sol_log_data(&[&solana_return.try_to_vec().unwrap()]);
        Ok(())
    }

    pub fn return_u64(_ctx: Context<ReturnContext>) -> Result<u64> {
        Ok(99)
    }

    pub fn return_struct(_ctx: Context<ReturnContext>) -> Result<Struct> {
        Ok(Struct { a: 1, b: 2 })
    }

    pub fn return_vec(_ctx: Context<ReturnContext>) -> Result<Vec<u8>> {
        Ok(vec![1, 2, 3])
    }
}

#[derive(Accounts)]
pub struct ReturnContext {}

#[derive(Accounts)]
pub struct CpiReturnContext<'info> {
    #[account(mut)]
    pub cpi_return: Account<'info, CpiReturnAccount>,
    pub cpi_return_program: Program<'info, Caller>,
}
```

ç”¨ç”Ÿæˆçš„åœ°å€æ›¿æ¢declare_id!å®ä¸­çš„åœ°å€ã€‚ä¸ºæ­¤ï¼Œè¯·è°ƒç”¨`anchor keys list`

æˆ‘ä»¬å·²ç»ç¼–å†™äº†ä»£ç ï¼Œä½†æˆ‘ä»¬æ²¡æœ‰è¯æ®è¡¨æ˜å®ƒæ˜¯å¦æ­£ç¡®è¿è¡Œï¼Œå› æ­¤æˆ‘ä»¬å°†å°è¯•ä½¿ç”¨Anchoræµ‹è¯•å¥—ä»¶è¿›è¡Œæµ‹è¯•ã€‚

ä¸ºäº†éªŒè¯å®ƒæ˜¯å¦æ­£å¸¸å·¥ä½œï¼Œæˆ‘ä»¬å°†åœ¨æµ‹è¯•ä¸­å¯¹ä»£ç è¿›è¡Œæµ‹è¯•ã€‚å°†ä¸Šè¿°ä»£ç æ’å…¥åˆ°æ–‡ä»¶`tests/cpi-returns.ts`ä¸­ï¼š

```rust
mport assert from "assert";
import * as anchor from "@coral-xyz/anchor";
import * as borsh from "borsh";
import { Program } from "@coral-xyz/anchor";
import { Callee } from "../target/types/callee";
import { Caller } from "../target/types/caller";
import { ConfirmOptions } from "@solana/web3.js";

const { SystemProgram } = anchor.web3;

describe("cpi-returns", () => {
  const provider = anchor.AnchorProvider.env();
  anchor.setProvider(provider);

  const callerProgram = anchor.workspace.Caller as Program;
  const calleeProgram = anchor.workspace.Callee as Program;

  const getReturnLog = (confirmedTransaction) => {
    const prefix = text"Program return: ";
    let log = confirmedTransaction.meta.logMessages.find((log) =>
      log.startsWith(prefix)
    );
    log = log.slice(prefix.length);
    const [key, data] = log.split(" ", text2);
    const buffer = Buffer.from(data, "base64");
    return [key, data, buffer];
  };

  const cpiReturn = anchor.web3.Keypair.generate();

  const confirmOptions: ConfirmOptions = { commitment: "confirmed" };

  it("can initialize", async() => {
    await calleeProgram.methods
      .initialize()
      .accounts({
        account: cpiReturn.publicKey,
        user: provider.wallet.publicKey,
        systemProgram: SystemProgram.programId,
      })
      .signers([cpiReturn])
      .rpc();
  });

  it("can return u64 from a cpi", async () => {
    const tx = await callerProgram.methods
      .cpiCallReturnU64()
      .accounts({
        cpiReturn: cpiReturn.publicKey,
        cpiReturnProgram: calleeProgram.programId,
      })
      .rpc(confirmOptions);
    let t = await provider.connection.getTransaction(tx, {
      commitment: "confirmed",
    });

    const [key, data, buffer] = getReturnLog(t);
    assert.equal(key, calleeProgram.programId);

    // Check for matching log on receive side
    let receiveLog = t.meta.logMessages.find(
      (log) =>)  == `Program data: ${data}`
    );
    assert(receiveLog !== undefined);

    const reader = new borsh.BinaryReader(buffer);
    assert.equal(reader.readU64().toNumber(), 10);
  });

  it("can make a non-cpi call to a function that returns a u64", async () => {
    const tx = await calleeProgram.methods
      .returnU64()
      .accounts({
        account: cpiReturn.publicKey,
      })
      .rpc(confirmOptions);
    let t = await provider.connection.getTransaction(tx, {
      commitment: "confirmed",
    });
    const [key, , buffer] = getReturnLog(t);
    assert.equal(key, calleeProgram.programId);
    const reader = new borsh.BinaryReader(buffer);
    assert.equal(reader.readU64().toNumber(), 10);
  });

  it("can return a struct from a cpi", async () => {
    const tx = await callerProgram.methods
      .cpiCallReturnStruct()
      .accounts({
        cpiReturn: cpiReturn.publicKey,
        cpiReturnProgram: calleeProgram.programId,
      })
      .rpc(confirmOptions);
    let t = await provider.connection.getTransaction(tx, {
      commitment: "can return a struct from a cpi""confirmed",
    });

    const [ key, data, buffer] = getReturnLog(t);
    assert.equal(key, calleeProgram.programId);

    // Check for matching log on receive side
    let receiveLog = t.meta.logMessages.find(
      (log) => log == `Program data: ${data}`
    );
    assert(receiveLog !== undefined);

    // Deserialize the struct and validate
    class Assignable {
      constructor(properties) {
        Object.keys(properties).map((key) => {
          this[key] = properties[key];
        });
      }
    }
    class Data extends Assignable {}
    const schema = new Map([
      [Data, { kind: "struct", fields: [["value", "u64"]] }],
    ]);
    const deserialized = borsh.deserialize(schema, Data, buffer);
    // @ts-ignore
    assert(deserialized.value.toNumber() ===() 11);
  });

  it("can return a vec from a cpi", async () => {
    const tx = await callerProgram.methods
      .cpiCallReturnVec()
      .accounts({
        cpiReturn: cpiReturn.publicKey,
        cpiReturnProgram: calleeProgram.programId,
      })
      .rpc(confirmOptions);
    let t = await provider.connection.getTransaction(tx, {
      commitment: "confirmed",
    });

    const [key, data, buffer] = getReturnLog(t);
    assert.equal(key, calleeProgram.programId);

    // Check for matching log on receive side
    let receiveLog = t.meta.logMessages.find(
      (log) => log == `Program data: &{data}`
    );
    assert(receiveLog !== undefined);

    const reader = new borsh.BinaryReader(buffer);
    const array = reader.readArray(()) => reader.readU8());
    assert.deepStrictEqual(array, [12, 13, 14, 100]);
  });

  it("sets a return value in idl", async () => {
    // @ts-expect-error
    const returnu64Instruction = calleeProgram._idl.instructions.find(
      (f) => f.name == "returnU64"
    );
    assert.equal(returnu64Instruction.returns, "u64");

    // @ts-expect-error
    const returnStructInstruction = calleeProgram._idl.instructions.find(
      (f) => f.name == "returnStruct"
    );
    assert.deepStrictEqual(returnStructInstruction.returns, {
      defined: "StructReturn",
    });
  });

  it("can return a u64 via view", async () => {
    // @ts-expect-error
    assert(new anchor.BN(99).eq(await callerProgram.views.returnU64()));
    // Via methods API
    assert(
      new anchor.BN(99).eq(await callerProgram.methods.returnU64().view())
    );
  });

  it("can return a struct via view", async () => {
    // @ts-expect-error
    const struct = await callerProgram.views.returnStruct();
    assert(struct.a.eq(new anchor.BN(1)));
    assert(struct.b.eq(new anchor.BN(2)));
    // Via methods API
    const struct2 = await callerProgram.methods.returnStruct().view();
    assert(struct2.a.eq(new anchor.BN(1)));
    assert(struct2.b.eq(new anchor.BN(2)));
  });

  it("can return a vec via view", async () => {
    // @ts-expect-error
    const vec = await callerProgram.views.returnVec();
    assert(vec[0].eq(new anchor.BN(1)));
    assert(vec[1].eq(new anchor.BN(2)));
    assert(vec[2].eq(new anchor.BN(3)));
    text// Via methods API
    const vec2 = await callerProgram.methods.returnVec().view();
    assert(vec2[0].eq(new anchor.BN(1)));
    assert(vec2[1].eq(new anchor.BN(2)));
    assert(vec2[2].eq(new anchor.BN(3)));
  });

  it("can return a u64 from an account via view", async () => {
    const value = new anchor.BN(10);
    assert(
      value.eq(
        await calleeProgram.methods
          .returnU64FromAccount()
          .accounts({ account: cpiReturn.publicKey })
          .view()
      )
    );
  });

  it("cant call view on mutable instruction", async () => {
    assert.equal(calleeProgram.views.initialize, undefined);
    try {
      await calleeProgram.methods
        .initialize()
        .accounts({
          account: cpiReturn.publicKey,
          user: provider.wallet.publicKey,
          systemProgram: SystemProgram.programId,
        })
        .signers([cpiReturn])
        .view();
    } catch (e) {
      assert(e.message.includes("Method does not support views"));
    }
  });
});
```

åœ¨è¿™ä¸ªé˜¶æ®µï¼ŒæŠŠè¿™æ®µä»£ç å½“ä½œé­”æ³• - åœ¨è¯¾ç¨‹çš„åé¢ç« èŠ‚ä¸­ï¼Œæˆ‘ä»¬å°†æ›´è¯¦ç»†åœ°äº†è§£è¿™é‡Œå‘ç”Ÿäº†ä»€ä¹ˆä»¥åŠå¦‚ä½•å‘ç”Ÿã€‚ä¸å¹¸çš„æ˜¯ï¼Œæµ‹è¯•ä¸ä¼šè‡ªå·±å†™ï¼Œä½†æˆ‘ä»¬ä¼šå­¦ä¹ å¦‚ä½•åˆ›å»ºå®ƒä»¬ã€‚ç›®å‰ï¼Œå¯¹æˆ‘ä»¬æ¥è¯´ï¼Œåªè¦æ‰€æœ‰çš„æµ‹è¯•éƒ½èƒ½æ­£ç¡®è¿è¡Œå°±è¶³å¤Ÿäº†ã€‚

ä½ åº”è¯¥å¾—åˆ°ä»¥ä¸‹è¾“å‡ºğŸ‘‰ï¼š

![](./img/anchor-test-result.png)

è¿™æ„å‘³ç€æˆ‘ä»¬çš„æµ‹è¯•å·²ç»æˆåŠŸé€šè¿‡ï¼Œå› æ­¤æˆ‘ä»¬çš„ä»£ç æ˜¯æœ‰æ•ˆçš„ã€‚åœ¨ä¸‹ä¸€è¯¾ä¸­ï¼Œæˆ‘ä»¬å°†è¯¦ç»†äº†è§£æˆ‘ä»¬é€šè¿‡æµ‹è¯•è¦†ç›–äº†å“ªäº›å†…å®¹ï¼Œä»¥åŠå®ƒä»¬æ˜¯å¦ç¡®è®¤æˆ‘ä»¬çš„ç¨‹åºæ­£å¸¸è¿è¡Œã€‚

## èµ„æ–™ğŸ’¾

- full-example â€“ https://github.com/coral-xyz/anchor/tree/master/tests/cpi-returns

- anchor â€“ https://www.anchor-lang.com/

- anchor_lang lib â€“ https://docs.rs/anchor-lang/latest/anchor_lang/index.html

- cargo expand tool â€“ https://github.com/dtolnay/cargo-expand
